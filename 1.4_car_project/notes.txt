For this project, you will be simulating a 10 x 10 grid on which cars can drive. At the beginning of the program, each location will have 5 cars waiting to enter the grid. Cars enter the grid with a predetermined random goal location. Your goal is to route all 500 cars to their goal location in as few ticks as possible while preventing two cars from occupying the same location at the same time (ie crashing into each other) or falling off the edge of the grid.

Each tick consists of:

1) Bringing onto the grid any number of cars

2) Turning any number of cars in any direction

3) Moving all currently active cars one space forward. **Note that every car will move every tick once it has been activated.**

You are responsible for deciding when cars come onto the grid and when active cars should turn. The code you are provided handles moving active cars forward each tick and checking for errors.

You MAY:

Access the next car that will enter in any given location using the peek method. Note that while the code design would allow you to access "deeper" cars, that breaks the rules. You shouldn't really need to access the inactive 3D list at all.
You may add helper methods and fields to the Location, Car, and Grid classes as necessary.
You MAY NOT:

Alter the main method in any way
Prevent the basic functionality of the problem from working. Ie you can't alter the code so that cars don't move, are allowed to crash, or move forward more than one space in a tick. 

Alter methods you have been provided, other than the updateAll method of the Grid class, where most of your work will happen.

In class the due date, you will present the algorithm you designed and an approximate number of ticks it requires. Note that a naive solution that simply routes one car at a time will require approximately 3300 ticks.

Project starter code is available below. Also, see the Word Document in the folder for more specifics on the tools available to you in each class.

**This idea is a slightly altered form of one by Professor Couch at Tufts University**

A collision is defined as two cars simultenaously land on the same block/grid after the updateall to move every car active on the grid by one step. Another valid collision can happen when you are trying to bring a car up to activate it but there's already a car there occupying the grid at that location; in that situation, you cannot bring the car up because another car is still there. 

Two cars going pass each other does not count as a collision. What I mean by this is that say car 1 position = (0,0) and car 2 = (1,0), and they swap position in the next run after they move, this does not count as a collision. 

use taxicab metrics for calculating distance?

how to simulate and find path?

the collision logic should already be defined by the given start code. also, if more than 1 car are all one last step until they reach their final destination, and they all have the same destination, I'm assuming that this doesn't count as a collision



Solution Thoughts:

I think the solution is as follows: 

Store: 
1. each car's two main direction (there should only be two directions that can give shortest distance); this can be useful later if there is a potential collision and it needs to make an emergency change of direction that's not one of those 2 directions. But worst case: what if all 4 directions could lead to a collision? I think to prevent that is to strategically pick the maximum number of cars each click.


Traffic Process:

Round 1:
1.) designate each row with a fixed first-step direction in which the cars in that row can move.
    The pattern can be: row1: -->, row2: <--, row3: v, row4: up
2.) In each row, peek at the cars that actually have goals that align with their fixed first-step direction. Store those in a list
2.5) Sort the list based on the car's distance to their goals
3.) Out of those cars with aligned direction for the first step, use the first element with the closest distance. If there are multiple with equidistance, pick the one with the smallest column number (so left-first priority sort of)
4.) The above would guarantee a maximum 10 cars moving each tick. Now, if the number didn't reach 10, loop back to the top row and find the next element (this should give you the next car with closest distance). If still hasn't reached 10, go to the next available row and pick the next car with the closest distance. This should create a situation where the more top the row is, the more cars it will have in that row.

4.5) Now, Simulate all 10 cars using taxicab metrics to see if there are any potential collision. 
5.) Simulate using horizontal-movement-first priority so that the cars will move to their desired column first; then, moves vertically for the desired row. 
(I'm not sure how we can simulate this and flag those cars that will cause collision with each other.) 
6.) If there are collisions detected between cars, flag those cars and store the position at which the collision will happen. Store the cars in a temporary list L, and we need to be able to tell which cars exactly they are.
7.) Activate the rest of the cars that don't cause collisions and move them to their goal. (is this necessary or should we just move all 10 cars all at the same time??)
8.) For those in L that will cause collision, we will move two at a time (?). (we'd also have to figure out how to pick the 2 each time). I picked 2 because if there is a collision detected after a simulation, len(L) is guaranteed to be >= 2. Moving 2 at a time can be easily dealt with (?) than say moving all the rest of the cars that will cause collisions at the same time (maybe?). At the flagged collision position, we will make one of them make an emergency turn. (Don't knwo how to implement this during each tick after the cars've been moved. How can we set this direction and when?). Then, reset the direction into each respective car's main direction. This should theoretically get all the cars to their goals. Make sure that before all the 10 cars in the list are moved to their goals, we do not activate any other car (?)
8.5) After step 7) and step 8) of moving the car, be sure to activate next car in that grid location up, only if that next available car has an aligned direction. 

9.) Now, repeat step 3)-8) to get the rest of the cars in each row to their location, until the length of the list (that has all the cars with aligned first step direction) is zero. When this happens, it should be the case that all the cars in each row who has an aligned first-step direction are moved to their goals. The grid should be empty now (?)



Round 2:
1.) designate a different fixed first-step direction for each row.
2.) the remaining logic should be identical to round 1

Round 3:
1.) designate a different fixed first-step direction for each row.
2.) the remaining logic should be identical to round 1

Round 4:
1.) designate a different fixed first-step direction for each row.
2.) the remaining logic should be identical to round 1

Now, repeat this flow (round1-4) with the fixed first-step direction for each round for each row. Terminates after all cars've been moved.


