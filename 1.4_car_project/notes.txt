For this project, you will be simulating a 10 x 10 grid on which cars can drive. At the beginning of the program, each location will have 5 cars waiting to enter the grid. Cars enter the grid with a predetermined random goal location. Your goal is to route all 500 cars to their goal location in as few ticks as possible while preventing two cars from occupying the same location at the same time (ie crashing into each other) or falling off the edge of the grid.

Each tick consists of:

1) Bringing onto the grid any number of cars

2) Turning any number of cars in any direction

3) Moving all currently active cars one space forward. **Note that every car will move every tick once it has been activated.**

You are responsible for deciding when cars come onto the grid and when active cars should turn. The code you are provided handles moving active cars forward each tick and checking for errors.

You MAY:

Access the next car that will enter in any given location using the peek method. Note that while the code design would allow you to access "deeper" cars, that breaks the rules. You shouldn't really need to access the inactive 3D list at all.
You may add helper methods and fields to the Location, Car, and Grid classes as necessary.
You MAY NOT:

Alter the main method in any way
Prevent the basic functionality of the problem from working. Ie you can't alter the code so that cars don't move, are allowed to crash, or move forward more than one space in a tick. 

Alter methods you have been provided, other than the updateAll method of the Grid class, where most of your work will happen.

In class the due date, you will present the algorithm you designed and an approximate number of ticks it requires. Note that a naive solution that simply routes one car at a time will require approximately 3300 ticks.

Project starter code is available below. Also, see the Word Document in the folder for more specifics on the tools available to you in each class.

**This idea is a slightly altered form of one by Professor Couch at Tufts University**

A collision is defined as two cars simultenaously land on the same block/grid after the updateall to move every car active on the grid by one step. Another valid collision can happen when you are trying to bring a car up to activate it but there's already a car there occupying the grid at that location; in that situation, you cannot bring the car up because another car is still there. 

Two cars going pass each other does not count as a collision. What I mean by this is that say car 1 position = (0,0) and car 2 = (1,0), and they swap position in the next run after they move, this does not count as a collision. 

use taxicab metrics for calculating distance?

how to simulate and find path?

the collision logic should already be defined by the given start code. also, if more than 1 car are all one last step until they reach their final destination, and they all have the same destination, I'm assuming that this doesn't count as a collision



Solution Thoughts:

I think the solution is as follows: 

## Complete Walkthrough: Car Routing Simulation

### Problem Recap

We have a 10×10 grid with 5 cars waiting at each of the 100 positions (500 cars total). Each car has a random goal location. Every tick, ALL active cars move forward one cell in whatever direction they're facing. We control:
1. When to activate (bring onto the grid) waiting cars
2. What direction each active car should face before it moves

We cannot pause cars, move them backward, or prevent them from moving once active. A collision occurs if two cars occupy the same cell after a tick's movement, or if we try to activate a car at a location that's already occupied.

---

### High-Level Strategy

**Core idea**: Before activating any cars, simulate their entire journey to the goal. Only activate cars whose paths don't conflict with each other (in both space AND time). Each tick, select the largest possible "cohort" of non-conflicting cars to activate, while also managing the directions of already-active cars.

**Routing policy**: All cars use "horizontal-first" routing. They move left/right until they reach their goal column, then move up/down until they reach their goal row. This creates predictable, deterministic paths.

---

### Data Structures We Need

**Global tick counter**: An integer tracking how many ticks have passed since the simulation started. Starts at 0.

**Car metadata storage**: For each active car, we need to remember:
- When it was activated (which global tick)
- Its planned direction sequence (a list of directions it should face at each step of its journey)

**Reserved cells table**: A lookup structure that answers "Is cell (row, col) occupied at tick T?" This is rebuilt every tick based on:
- Projected future positions of all currently active cars
- Projected paths of cars we're considering activating

---

### The Main Loop (What Happens Each Tick)

The simulation alternates between `updateAll()` (which we write) and `step()` (which is provided). Here's what happens each tick:

```
REPEAT until all 500 cars have reached their goals:
    1. updateAll() is called — we decide what to do
    2. step() is called — all active cars move forward one cell
```

---

### Detailed Logic for updateAll()

This is the heart of our solution. Each time `updateAll()` is called, we do the following:

#### Phase 1: Set Directions for Already-Active Cars

Before we think about new cars, we need to make sure every car that's already on the grid is facing the correct direction for its next move.

```
FOR each cell (row, col) on the grid:
    IF there's an active car at this cell:
        Figure out how many ticks this car has been active
        Look up its direction sequence
        Find the direction it should face this tick
        Call setDirection on the car with that direction
```

**Example**: A car was activated at global tick 5. It's now global tick 8, so the car has been active for 3 ticks and has already moved 3 times. We look at position 3 in its direction sequence to find what direction it should face for its 4th move.

#### Phase 2: Project Future Positions of Active Cars

Before selecting new cars, we need to know where all the active cars will be at every future tick until they reach their goals.

```
Create an empty reserved cells table

FOR each active car on the grid:
    Calculate its current position
    Calculate how many moves it has left to reach its goal
    
    FOR each future tick until it reaches its goal:
        Calculate where it will be at that tick
        Mark that (row, col, tick) as reserved in the table
```

**Example**: An active car is at (3, 5) heading to (3, 8). It needs 3 more moves (all to the right). If the current global tick is 10, we reserve:
- (3, 6) at global tick 11
- (3, 7) at global tick 12
- (3, 8) at global tick 13

#### Phase 3: Gather Candidate Cars for Activation

Now we look at all positions on the grid and identify cars that *could* potentially be activated this tick.

```
Create an empty list of candidates

FOR each cell (row, col) on the grid:
    IF there's NO active car at this cell:
        Peek at the next waiting car at this cell
        IF there is a waiting car:
            Compute its full path from (row, col) to its goal
            Calculate the path length (number of ticks to reach goal)
            Add this car to the candidates list with its path info
```

A car's path is a sequence of positions it will occupy at each tick after activation. For horizontal-first routing:

```
To compute path for a car at (startRow, startCol) going to (goalRow, goalCol):
    
    Create empty path list
    Set currentRow = startRow, currentCol = startCol
    Set tick = 0 (relative to when this car is activated)
    
    // Horizontal movement phase
    WHILE currentCol ≠ goalCol:
        Increment tick
        IF goalCol > currentCol:
            Move right: currentCol = currentCol + 1
        ELSE:
            Move left: currentCol = currentCol - 1
        Add (currentRow, currentCol, tick) to path
    
    // Vertical movement phase
    WHILE currentRow ≠ goalRow:
        Increment tick
        IF goalRow > currentRow:
            Move down: currentRow = currentRow + 1
        ELSE:
            Move up: currentRow = currentRow - 1
        Add (currentRow, currentCol, tick) to path
    
    Return path
```

**Example**: Car at (2, 1) with goal (0, 3).

Horizontal first: move right from col 1 to col 3 (2 moves), then move up from row 2 to row 0 (2 moves).

Path (using relative ticks):
- Tick 0: (2, 1) — starting position
- Tick 1: (2, 2) — moved right
- Tick 2: (2, 3) — moved right, now at goal column
- Tick 3: (1, 3) — moved up
- Tick 4: (0, 3) — moved up, reached goal

#### Phase 4: Sort Candidates

We want to prioritize certain cars to maximize throughput. Sorting by path length (shortest first) is a good heuristic because:
- Short-path cars clear quickly, freeing up space
- They reserve fewer cells, leaving room for more cars in the cohort

```
Sort candidates by path length, shortest first

IF two candidates have equal path length:
    Break ties by position (e.g., top-left first) for consistency
```

#### Phase 5: Greedy Cohort Selection

Now we iterate through candidates and add them to our cohort if they don't conflict with anything already reserved.

```
Create empty list of selected cars (the cohort)

FOR each candidate in sorted order:
    Convert the candidate's path from relative ticks to global ticks
    (If global tick is 10, the car's tick 0 becomes global tick 10,
     tick 1 becomes global tick 11, etc.)
    
    Check for conflicts:
        Set hasConflict = false
        FOR each (row, col, globalTick) in the converted path:
            IF (row, col, globalTick) is in the reserved cells table:
                Set hasConflict = true
                BREAK out of loop
    
    IF hasConflict is false:
        Add this candidate to the selected cohort
        FOR each (row, col, globalTick) in the converted path:
            Mark (row, col, globalTick) as reserved
        
        Also store this car's direction sequence for Phase 1 in future ticks
```

**Why greedy works**: We can't efficiently find the true maximum cohort (it's NP-hard), but greedy gives us a good approximation. By sorting shortest-first, we tend to fit more cars because short paths "use up" less of the space-time grid.

#### Phase 6: Activate Selected Cars

```
FOR each car in the selected cohort:
    Get the car's starting location
    Call activateCar(location) to bring it onto the grid
    Set its initial direction based on its direction sequence
```

#### Phase 7: Increment Global Tick

```
Increment global tick counter by 1
```

---

### Computing the Direction Sequence

When we select a car for activation, we also precompute the sequence of directions it should face at each tick of its journey.

```
To compute direction sequence for car at (startRow, startCol) going to (goalRow, goalCol):
    
    Create empty direction list
    Set currentCol = startCol, currentRow = startRow
    
    // Horizontal movement directions
    WHILE currentCol ≠ goalCol:
        IF goalCol > currentCol:
            Add RIGHT (3) to direction list
            currentCol = currentCol + 1
        ELSE:
            Add LEFT (2) to direction list
            currentCol = currentCol - 1
    
    // Vertical movement directions
    WHILE currentRow ≠ goalRow:
        IF goalRow > currentRow:
            Add DOWN (1) to direction list
            currentRow = currentRow + 1
        ELSE:
            Add UP (0) to direction list
            currentRow = currentRow - 1
    
    Return direction list
```

**Example**: Car at (2, 1) going to (0, 3).
- Directions: [RIGHT, RIGHT, UP, UP] or [3, 3, 0, 0]

At tick 0 of this car's journey, it faces RIGHT.
At tick 1, it faces RIGHT again.
At tick 2, it faces UP.
At tick 3, it faces UP.
After tick 3's movement, it reaches (0, 3) and is removed.

---

### Handling Edge Cases

**What if a car's spawn point stays blocked?**

If cell (r, c) has an active car, we can't activate the next waiting car there. It simply stays in the candidates list and gets reconsidered next tick. Eventually the active car moves away.

**What if the reserved table gets too large?**

In the worst case, we might have paths extending 18+ ticks into the future (maximum Manhattan distance on a 10×10 grid is 18). With up to ~100 active cars, that's manageable. The table is rebuilt fresh each tick anyway.

**What about cars reaching their goal simultaneously?**

The provided code handles this: when a car reaches its goal in `step()`, it's removed *before* collision checking. So two cars arriving at the same goal on the same tick don't collide—they both just get removed.

**What if horizontal-first creates too many conflicts?**

This could happen if many cars need to cross the same column. An optimization would be to try vertical-first for some cars when horizontal-first fails. But for a first implementation, pure horizontal-first should work reasonably well.

---

### Worked Example of One Tick

**Setup**: Global tick is 0. Grid is empty. Let's say we have these waiting cars (simplified to just 4):

| Position | Goal | Path (relative ticks) | Length |
|----------|------|----------------------|--------|
| (0, 0) | (0, 2) | (0,0,0)→(0,1,1)→(0,2,2) | 3 |
| (0, 1) | (2, 1) | (0,1,0)→(1,1,1)→(2,1,2) | 3 |
| (1, 0) | (1, 2) | (1,0,0)→(1,1,1)→(1,2,2) | 3 |
| (2, 2) | (0, 0) | (2,2,0)→(2,1,1)→(2,0,2)→(1,0,3)→(0,0,4) | 5 |

**Phase 1**: No active cars yet, nothing to do.

**Phase 2**: Reserved table starts empty.

**Phase 3**: All 4 are candidates.

**Phase 4**: Sort by length. First three are tied at length 3, last one is length 5.

**Phase 5**: Greedy selection.

- **Car A at (0,0)**: Path is (0,0,0), (0,1,1), (0,2,2). No conflicts. SELECT. Reserve these cells.

- **Car B at (0,1)**: Path is (0,1,0), (1,1,1), (2,1,2). Check conflicts:
  - (0,1,0): Not reserved. OK.
  - (1,1,1): Not reserved. OK.
  - (2,1,2): Not reserved. OK.
  - No conflicts. SELECT. Reserve these cells.

- **Car C at (1,0)**: Path is (1,0,0), (1,1,1), (1,2,2). Check conflicts:
  - (1,0,0): Not reserved. OK.
  - (1,1,1): **RESERVED by Car B!** CONFLICT. SKIP.

- **Car D at (2,2)**: Path is (2,2,0), (2,1,1), (2,0,2), (1,0,3), (0,0,4). Check conflicts:
  - None of these are reserved. SELECT. Reserve these cells.

**Result**: Cohort is {Car A, Car B, Car D}. Car C waits.

**Phase 6**: Activate cars A, B, D. Set their initial directions.

**Phase 7**: Global tick becomes 1.

**Then step() runs**: All three cars move forward one cell.

**Next tick**: Car C will be reconsidered. By then, Car B has moved away from (1,1,1) in the global timeline, so there may no longer be a conflict.

---

### Expected Performance

With this approach:
- Each tick, we potentially activate 10-50 cars (depends on conflict density)
- Average path length is ~6-7 cells (expected Manhattan distance on 10×10 grid)
- Total ticks should be roughly 200-400, compared to 3300 for the naive one-at-a-time approach

---

### Summary Checklist

1. **Track global tick** — know what "time" it is in the simulation
2. **For each active car, remember its direction sequence** — so we can set its direction each tick
3. **Each tick, first set directions for all active cars** — they need to face the right way before step() moves them
4. **Project all active cars' future positions into reserved table** — so new cars don't collide with them
5. **Gather candidates from peek()** — any cell without an active car is a potential activation point
6. **Compute each candidate's path using horizontal-first routing** — deterministic, predictable paths
7. **Sort candidates by path length** — short paths first
8. **Greedily select non-conflicting candidates** — check against reserved table, add if clear
9. **Activate selected cars and store their direction sequences** — bring them onto grid
10. **Increment global tick** — prepare for next iteration

---

Thoughts for improvement:

should we improve or revise in the way we select candidates?
For presentation, we should probably create a batch script that runs the simulation a lot of times and then sorts of graphs and visualizes the results.

